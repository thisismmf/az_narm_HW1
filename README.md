<div dir="rtl">
# آزمایشگاه مهندسی نرم‌افزار
## آزمایش اول
### اطلاعات دانشجویان
**دانا افاضلی** 98105592

**محمدمهدی فرهادی** 99105634

**محمدامین کرمی** 98105998


### گزارش آزمایش

این پروژه شامل پیاده‌سازی یک وب‌سایت استاتیک و خودکارسازی استقرار با GitHub Actions است. مراحل اصلی به صورت خلاصه:

#### 1. راه‌اندازی مخزن
- `git init` → ساخت مخزن محلی (`.git` حاوی تاریخچه، شاخه‌ها و تنظیمات).
- ایجاد شاخه‌ی `main` (محافظت شده) و `dev` برای توسعه.

#### 2. ساختاردهی فایل‌ها
- قراردادن `index.html` در ریشه و پوشه‌های `statics/css` و `statics/js`.
- افزودن `.gitignore` برای حذف فایل‌های موقتی (مثل `node_modules/`, `.DS_Store`).

#### 3. توسعه به‌صورت شاخه‌ای
- هر ویژگی جدید در شاخه‌ای مجزا (مثلاً `feature/navbar-improvements`) پیاده شد.
- پس از تکمیل، Pull Request به `dev` (و در صورت hotfix به `main`) ایجاد و Merge شد.

#### 4. حل تعارض‌ها
- دو conflict عمده در `gallery.js` و `header.js` هنگام Merge شاخه‌ها رخ داد.
- با ویرایش دستی و Commit پیام‌دار، تعارض‌ها رفع شدند.

#### 5. تست Dark Mode (Task #10)
- کلیک روی سوئیچ Dark Mode در navbar تغییر رنگ پس‌زمینه و متن را در Chrome و Firefox بررسی کردیم.
- عملکرد صحیح در موبایل و دسکتاپ تأیید شد.

#### 6. خودکارسازی استقرار
- ایجاد فایل `.github/workflows/deploy.yaml` برای deploy خودکار روی GitHub Pages با هر Push به `main`.
- تنظیم Branch Protection برای Require PR review روی `main`.

#### 7. نتیجه نهایی
- بیش از ۲۰ Commit معنادار در چهار شاخه (`main`, `dev`, feature, hotfix`).
- حداقل دو conflict حل شده.
- وب‌سایت روی GitHub Pages به‌صورت خودکار منتشر می‌شود.


### پاسخ به سوالات

#### پوشه‌ی `.git` چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

پوشه‌ی `.git` یک دایرکتوری مخفی است که توسط Git در ریشه‌ی پروژه ایجاد می‌شود و تمامی اطلاعات مربوط به مخزن Git را در خود نگه می‌دارد. این پوشه شامل متادیتاها، اشیاء (objects)، مراجع (references)، تنظیمات و تاریخچه‌ی تغییرات پروژه است. به عبارتی، این پوشه قلب مخزن Git محسوب می‌شود و نباید حذف یا تغییر داده شود، زیرا باعث از دست رفتن تاریخچه و اطلاعات نسخه‌بندی پروژه خواهد شد. برای ایجاد این پوشه، از دستور `git init` استفاده می‌شود که یک مخزن Git جدید در دایرکتوری فعلی ایجاد می‌کند.

---
#### منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

منظور از "اتمی" بودن (atomic) در مفاهیمی مانند "تعهد اتمی" (atomic commit) و "درخواست کشش اتمی" (atomic pull-request)، این است که عملیات مورد نظر به صورت کامل و یکپارچه انجام شود یا اصلاً انجام نشود. به عبارت دیگر، یک تعهد اتمی شامل تغییراتی است که به صورت منطقی به هم مرتبط هستند و باید به صورت یک واحد مستقل اعمال شوند. این رویکرد باعث می‌شود که هر تعهد (commit) حاوی تغییرات مشخص و مرتبط باشد که درک و پیگیری تاریخچه‌ی پروژه را ساده‌تر می‌کند. در مورد درخواست کشش اتمی، تمام تغییرات مرتبط در یک درخواست گنجانده می‌شوند تا بررسی و ادغام آن‌ها به صورت یکپارچه و مستقل انجام شود.

--- 

#### تفاوت دستورهای `fetch` و `pull` و `merge` و `rebase` و `cherry-pick` را بیان کنید.

- **`git fetch`**: این دستور تغییرات موجود در مخزن راه دور (remote) را واکشی کرده و آن‌ها را به مخزن محلی دانلود می‌کند، بدون اینکه تغییرات را با شاخه‌ی فعلی ادغام کند. این امکان را می‌دهد که تغییرات را بررسی کرده و در صورت نیاز به صورت دستی ادغام نمایید.

- **`git pull`**: این دستور ترکیبی از `fetch` و `merge` است. ابتدا تغییرات را از مخزن راه دور دانلود کرده و سپس آن‌ها را با شاخه‌ی فعلی ادغام می‌کند. این روش سریع‌ترین راه برای به‌روز رسانی شاخه‌ی محلی با تغییرات مخزن راه دور است. :contentReference[oaicite:1]{index=1}

- **`git merge`**: این دستور تغییرات یک شاخه را به شاخه‌ی فعلی ادغام می‌کند و یک تعهد (commit) جدید ایجاد می‌کند که ترکیبی از تغییرات دو شاخه است. این روش تاریخچه‌ی کامل تغییرات را حفظ می‌کند و ترتیب وقوع آن‌ها را نشان می‌دهد. :contentReference[oaicite:2]{index=2}

- **`git rebase`**: این دستور تغییرات یک شاخه را بر پایه‌ی شاخه‌ی دیگر بازنویسی می‌کند. به عبارتی، تعهدات شاخه‌ی فعلی را بر روی سر شاخه‌ی مقصد اعمال می‌کند و تاریخچه را به صورت خطی نمایش می‌دهد. این روش می‌تواند تاریخچه‌ی تمیزتری ایجاد کند، اما باید با دقت استفاده شود تا از مشکلات احتمالی جلوگیری شود. :contentReference[oaicite:3]{index=3}

- **`git cherry-pick`**: این دستور به شما امکان می‌دهد یک تعهد خاص را از یک شاخه انتخاب کرده و آن را به شاخه‌ی فعلی اعمال کنید. این روش برای زمانی مفید است که می‌خواهید تغییرات خاصی را بدون ادغام کامل شاخه‌ها به شاخه‌ی خود اضافه کنید. 

---

#### تفاوت دستورهای `reset` و `revert` و `restore` و `switch` و `checkout` را بیان کنید.

- **`git reset`**: این دستور به شما امکان می‌دهد شاخه‌ی فعلی را به یک نقطه‌ی قبلی در تاریخچه بازگردانید. این عمل می‌تواند تغییرات را در شاخه‌ی فعلی و یا در مرحله‌بندی (staging area) تحت تأثیر قرار دهد و حتی ممکن است تغییرات را از تاریخچه حذف کند.

- **`git revert`**: این دستور یک تعهد جدید ایجاد می‌کند که تغییرات تعهد مشخصی را معکوس می‌کند. به عبارتی، بدون حذف تاریخچه، تغییرات یک تعهد خاص را بازمی‌گرداند و یک تعهد جدید برای این عمل ایجاد می‌کند.

- **`git restore`**: این دستور برای بازیابی فایل‌ها به وضعیت قبلی استفاده می‌شود. می‌توانید تغییرات یک فایل را در دایرکتوری کاری یا مرحله‌بندی بازگردانید.

- **`git switch`**: این دستور برای تغییر بین شاخه‌ها استفاده می‌شود و جایگزینی برای برخی از کاربردهای `checkout` است. این دستور به صورت خاص برای تغییر شاخه طراحی شده است.

- **`git checkout`**: این دستور برای تغییر شاخه‌ها یا بازیابی فایل‌ها به یک نسخه‌ی قبلی استفاده می‌شود. با این حال، به دلیل داشتن وظایف متعدد، دستورهای `switch` و `restore` معرفی شدند تا وظایف مشخص‌تری را انجام دهند.

---
#### منظور از stage یا همان index چیست؟ دستور `stash` چه کاری را انجام می‌دهد؟

- **Stage (یا Index)**: مرحله‌بندی (staging area) یا ایندکس، محلی است که تغییرات فایل‌ها قبل از تعهد (commit) در آن قرار می‌گیرند. این مکان به شما امکان می‌دهد تغییرات مورد نظر خود را برای تعهد بعدی انتخاب کنید و فقط آن‌ها را در تعهد خود لحاظ نمایید.

- **`git stash`**: این دستور تغییرات جاری در دایرکتوری کاری و مرحله‌بندی را به صورت موقت ذخیره می‌کند و دایرکتوری کاری را به حالت آخرین تعهد بازمی‌گرداند. این روش برای زمانی مفید است که می‌خواهید به صورت موقت تغییرات خود را کنار بگذارید تا روی موضوع دیگری کار کنید و سپس تغییرات موقت را بازیابی نمایید.

---

#### مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟

در Git، هر تعهد (commit) یک لحظه‌نگار (snapshot) از کل پروژه در زمان تعهد است. به عبارتی، هر تعهد نمایانگر وضعیت کامل پروژه در لحظه‌ی ایجاد آن است. این روش ذخیره‌سازی به Git امکان می‌دهد تا به سرعت و کارآمدی به نسخه‌های قبلی پروژه بازگردد و تاریخچه‌ی کاملی از تغییرات را نگه‌داری کند.

---

#### تفاوت‌های local repository و remote repository چیست؟

- **Local Repository**:
  - روی کامپیوتر توسعه‌دهنده قرار دارد.
  - شامل کل تاریخچهٔ پروژه و تغییرات است.
  - مستقل از اینترنت عمل می‌کند.
  - سریع‌تر و مناسب برای کارهای آفلاین است.

- **Remote Repository**:
  - روی سرور (مثلاً GitHub یا GitLab) قرار دارد.
  - برای همکاری بین اعضای تیم استفاده می‌شود.
  - نیاز به اتصال اینترنت دارد.
  - محل اشتراک‌گذاری تغییرات است.

### تعامل بین آن‌ها:
- `clone`: ایجاد مخزن محلی از راه دور.
- `fetch`: دریافت تغییرات جدید از راه دور بدون ادغام.
- `pull`: دریافت و ادغام تغییرات.
- `push`: ارسال تغییرات محلی به مخزن راه دور.

</div>